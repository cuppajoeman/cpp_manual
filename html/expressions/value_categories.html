<p>Every expression in C++ has a value category. Modern C++ uses three primary categories:</p>

<ul>
  <li><code>prvalue</code></li>
  <li><code>xvalue</code></li>
  <li><code>lvalue</code></li>
</ul>


<h2>evolution of value categories</h2>

<p>
  The usage of l and r in the naming came from the idea of the left and right hand side of an assignment statement. In C we had code like this:
</p>

<pre>
  <code>
    int i;
    i = 42; // ok
    42 = i; // error
  </code>
</pre>

<p>
  From this basic example we can deduce what types of things can be on the left vs right side of an assignment statement. This gave a way of categorizing expressions either as l-values or r-values. From here we can see what types of operations are avilable for different value categories:
</p>

<pre>
  <code>
    int* p = &i; // getting the memory address of an l-value is fine
    int* q = &42 // error, you can't get the memory address of an r-value
  </code>
</pre>

<p>
  But in modern c++ this is no longer this case since assignment position no longer determines the value category, because the following code valid:
</p>

<pre>
  <code>
    std::string s;
    std::move(s) = "hello"; // valid it acts like an l-value
    // if std::move(...) acts like an l-value then we can get the reference of it right?
    auto sp = &std::move(s); // error 
  </code>
</pre>

<p>
  The above example proves that with c++ std::move(...)'s valid category is neither an l-value nor an r-value.
</p>

<h2>Pure R-value (prvalue)</h2>
<p>
  A <strong>prvalue</strong> is a value that does not have identity. It typically
  represents a temporary or a computed value. Evaluating a prvalue initializes
  an object but does not refer to an existing object with identity.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>3
x + y
std::string("hello")
  </code>
</pre>

<h2>Expiring Value (xvalue)</h2>
<p>
  An <strong>xvalue</strong> is an expression that has identity but whose resources
  can be reused (about to expire). Xvalues arise from certain rvalue expressions,
  such as a function returning an rvalue reference.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>
std::move(obj)       // object with identity but eligible for reuse
f().member           // if f() returns T&&
</code>
</pre>

<h2>L-Value (lvalue)</h2>
<p>
  An <strong>lvalue</strong> refers to an object with identity. It has a stable
  location in memory and cannot bind to rvalue references. Most named variables
  and objects are lvalues.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>
x           // named variable
arr[i]      // subscript produces lvalue
*p          // dereferencing a pointer
  </code>
</pre>



<h2>Universal/Forwarding Reference</h2>
<p>
  Suppose we have the following code:
</p>
<pre>
<code>
#include <iostream>
#include <string>
#include <utility> // for std::move

// 1. Accept const lvalue reference: we just want to read it
void log_internal(const std::string& msg) {
    std::cout << "Logging const lvalue reference: " << msg << "\n";
}

// 2. Accept non-const lvalue reference: we might modify it
void log_internal(std::string& msg) {
    msg += " [logged]";
    std::cout << "Logging non-const lvalue reference: " << msg << "\n";
}

// 3. Accept rvalue reference: we can move it
void log_internal(std::string&& msg) {
    std::cout << "Logging rvalue reference: " << msg << "\n";
}

int main() {
    std::string s1 = "Hello";
    const std::string s2 = "World";

    log_internal(s1);        // calls non-const lvalue
    log_internal(s2);        // calls const lvalue
    log_internal("Temp!");   // calls rvalue

    return 0;
}
</code>
</pre>

<p>
  Now we realize that we want to be able to log <strong>anything</strong>, not just strings. A naive approach would be to create three different template signatures:
</p>
<pre>
<code>
template <typename T>
void log_internal(const T& msg) { ... }

template <typename T>
void log_internal(T& msg) { ... }

template <typename T>
void log_internal(T&& msg) { ... }
</code>
</pre>

<p>
  The problem with this approach is that templates are supposed to reduce boilerplate, but here we are duplicating code three times. This goes against the very purpose of templates.
</p>

<h3>The proper way: Universal/Forwarding References</h3>
<p>
  Instead of writing three templates, we can use a <em>universal reference</em> and <code>std::forward</code> to perfectly forward the argument to the correct internal function. Here's an example:
</p>
<pre>
<code>
#include <iostream>
#include <string>
#include <utility> // for std::forward

// Internal implementations
void log_internal_impl(const std::string& msg) {
    std::cout << "Logging const lvalue reference: " << msg << "\n";
}

void log_internal_impl(std::string& msg) {
    msg += " [logged]";
    std::cout << "Logging non-const lvalue reference: " << msg << "\n";
}

void log_internal_impl(std::string&& msg) {
    std::cout << "Logging rvalue reference: " << msg << "\n";
}

// Forwarding template
template <typename T>
void log_internal(T&& msg) {             // universal reference
    log_internal_impl(std::forward<T>(msg));
}

int main() {
    std::string s1 = "Hello";
    const std::string s2 = "World";

    log_internal(s1);        // calls non-const lvalue
    log_internal(s2);        // calls const lvalue
    log_internal("Temp!");   // calls rvalue

    return 0;
}
</code>
</pre>

<p>
  <strong>Why this works:</strong>
</p>
<ul>
  <li><code>T&&amp</code> in a template is a <em>forwarding (universal) reference</em>, which can bind to both lvalues and rvalues.</li>
  <li><code>std::forward<T>(msg)</code> preserves the original value category: it forwards lvalues as lvalues and rvalues as rvalues.</li>
  <li>We now only need a single template function instead of three, keeping the code clean and maintainable.</li>
</ul>

<h2>Definitions</h2>
<div class="definition" id="definition-lvalue">
  <p>
    A <strong>prvalue</strong> is an expression that is one of the following:
  </p>
  <ul>
    <li>The name of a variable, a function, a template parameter object (since C++20), or a data member, regardless of type. Even if the variable's type is an rvalue reference, the expression consisting of its name is an lvalue (except move-eligible expressions).</li>
    <li>A function call or an overloaded operator expression whose return type is an lvalue reference, such as <code>std::getline(std::cin, str)</code>, <code>str1 = str2</code>, or <code>++it</code>.</li>
    <li>Assignment and compound assignment expressions, such as <code>a = b</code>, <code>a += b</code>, <code>a %= b</code>, etc.</li>
    <li>Pre-increment and pre-decrement expressions, <code>++a</code> and <code>--a</code>.</li>
    <li>The built-in indirection expression, <code>*p</code>.</li>
    <li>Built-in subscript expressions, <code>a[n]</code> and <code>p[n]</code>, where one operand in <code>a[n]</code> is an array lvalue (since C++11).</li>
    <li>Member of object expressions, <code>a.m</code>, except where <code>m</code> is a member enumerator or non-static member function, or where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of object type.</li>
    <li>Built-in member of pointer expressions, <code>p->m</code>, except where <code>m</code> is a member enumerator or non-static member function.</li>
    <li>Pointer to member of object expressions, <code>a.*mp</code>, where <code>a</code> is an lvalue and <code>mp</code> is a pointer to data member.</li>
    <li>Built-in pointer to member of pointer expressions, <code>p->*mp</code>, where <code>mp</code> is a pointer to data member.</li>
    <li>Built-in comma expressions, <code>a, b</code>, where <code>b</code> is an lvalue.</li>
    <li>Ternary conditional expressions, <code>a ? b : c</code>, for certain <code>b</code> and <code>c</code> (e.g., when both are lvalues of the same type).</li>
    <li>String literals, such as <code>"Hello, world!"</code>.</li>
    <li>Cast expressions to lvalue reference type, such as <code>static_cast&lt;int&amp;&gt;(x)</code> or <code>static_cast&lt;void(&)(int)&gt;(x)</code>.</li>
    <li>Constant template parameters of an lvalue reference type.</li>
  </ul>
</div>


<div class="definition" id="definition-prvalue">
  <p>
    A <strong>prvalue</strong> is an expression that is one of the following:
  </p>
  <ul>
    <li>A literal (except for string literal), such as <code>42</code>, <code>true</code>, or <code>nullptr</code>.</li>
    <li>A function call or overloaded operator expression whose return type is non-reference, e.g., <code>str.substr(1, 2)</code>, <code>str1 + str2</code>, or <code>it++</code>.</li>
    <li><code>a++</code> and <code>a--</code>, the built-in post-increment and post-decrement expressions.</li>
    <li>Arithmetic expressions such as <code>a + b</code>, <code>a % b</code>, <code>a & b</code>, <code>a << b</code>, and other built-in arithmetic operators.</li>
    <li>Logical expressions such as <code>a && b</code>, <code>a || b</code>, <code>!a</code>.</li>
    <li>Comparison expressions such as <code>a < b</code>, <code>a == b</code>, <code>a >= b</code>, and others.</li>
    <li>The built-in address-of expression <code>&a</code>.</li>
    <li>Member expressions like <code>a.m</code> (where <code>m</code> is a member enumerator or non-static member function), <code>p->m</code>, <code>a.*mp</code> (pointer to member function), and <code>p->*mp</code>.</li>
    <li>The built-in comma expression <code>a, b</code>, where <code>b</code> is a prvalue.</li>
    <li>The ternary conditional expression <code>a ? b : c</code> for certain <code>b</code> and <code>c</code> (see C++ standard for details).</li>
    <li>A cast expression to non-reference type, such as <code>static_cast&lt;double&gt;(x)</code>, <code>std::string{}</code>, or <code>(int)42</code>.</li>
    <li>The <code>this</code> pointer.</li>
    <li>An enumerator.</li>
    <li>A constant template parameter of a scalar type</li>
    <li>A lambda expression, e.g., <code>[] (int x) { return x * x; }</code> (since C++11).</li>
    <li>A requires-expression, e.g., <code>requires (T i) { typename T::type; }</code> (since C++20).</li>
    <li>A specialization of a concept, e.g., <code>std::equality_comparable&lt;int&gt;</code> (since C++20).</li>
  </ul>
</div>


<div class="definition" id="definition-xvalue">
  <p>
    A <strong>xvalue</strong> is an expression that is one of the following:
  </p>
  <ul>
    <li><code>a.m</code>, the member of object expression, where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of an object type.</li>
    <li><code>a.*mp</code>, the pointer to member of object expression, where <code>a</code> is an rvalue and <code>mp</code> is a pointer to data member.</li>
    <li><code>a, b</code>, the built-in comma expression, where <code>b</code> is an xvalue.</li>
    <li><code>a ? b : c</code>, the ternary conditional expression, where either <code>b</code> or <code>c</code> is an xvalue</li>
    <li>A function call or overloaded operator expression whose return type is an rvalue reference to object, such as <code>std::move(x)</code>.</li>
    <li><code>a[n]</code>, the built-in subscript expression, where one operand is an array rvalue.</li>
    <li>A cast expression to rvalue reference to object type, such as <code>static_cast<char&&&>(x)</code>.</li>
    <li>Any expression that designates a temporary object, after temporary materialization (since C++17).</li>
    <li>A move-eligible expression (since C++17).</li>
  </ul>
</div>
      
<div class="definition" id="definition-glvalue">
  <p>
    A <strong>glvalue</strong> is an expression that either an  <a class="rlink" href="/expressions/value_categories#definition-lvalue">lvalue</a> or an  <a class="rlink" href="/expressions/value_categories#definition-xvalue">xvalue</a>.
  </p>
</div>

<div class="definition" id="definition-rvalue">
  <p>
    An <strong>rvalue</strong> is an expression that either an  <a class="rlink" href="/expressions/value_categories#definition-prvalue">prvalue</a> or an  <a class="rlink" href="/expressions/value_categories#definition-xvalue">xvalue</a>.
  </p>
</div>

