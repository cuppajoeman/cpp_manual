<p>Every expression in C++ has a value category. Modern C++ uses three primary categories:</p>

<ul>
  <li><code>prvalue</code></li>
  <li><code>xvalue</code></li>
  <li><code>lvalue</code></li>
</ul>

<h2>evolution of value categories</h2>

<p>
  The usage of l and r in the naming came from the idea of the left and right hand side of an assignment statement. In C we had code like this:
</p>

<pre>
  <code>
    int i;
    i = 42; // ok
    42 = i; // error
  </code>
</pre>

<p>
  From this basic example we can deduce what types of things can be on the left vs right side of an assignment statement. This gave a way of categorizing expressions either as l-values or r-values. From here we can see what types of operations are avilable for different value categories:
</p>

<pre>
  <code>
    int* p = &i; // getting the memory address of an l-value is fine
    int* q = &42 // error, you can't get the memory address of an r-value
  </code>
</pre>

<p>
  But in modern c++ this is no longer this case since assignment position no longer determines the value category, because the following code valid:
</p>

<pre>
  <code>
    std::string s;
    std::move(s) = "hello"; // valid it acts like an l-value
    // if std::move(...) acts like an l-value then we can get the reference of it right?
    auto sp = &std::move(s); // error 
  </code>
</pre>

<p>
  The above example proves that with c++ std::move(...)'s valid category is neither an l-value nor an r-value.
</p>

<h2>Pure R-value (prvalue)</h2>
<p>
  A <strong>prvalue</strong> is a value that does not have identity. It typically
  represents a temporary or a computed value. Evaluating a prvalue initializes
  an object but does not refer to an existing object with identity.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>3
x + y
std::string("hello")
  </code>
</pre>

<h2>Expiring Value (xvalue)</h2>
<p>
  An <strong>xvalue</strong> is an expression that has identity but whose resources
  can be reused (about to expire). Xvalues arise from certain rvalue expressions,
  such as a function returning an rvalue reference.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>
std::move(obj)       // object with identity but eligible for reuse
f().member           // if f() returns T&&
</code>
</pre>

<h2>L-Value (lvalue)</h2>
<p>
  An <strong>lvalue</strong> refers to an object with identity. It has a stable
  location in memory and cannot bind to rvalue references. Most named variables
  and objects are lvalues.
</p>
<p><strong>Examples:</strong></p>
<pre>
  <code>
x           // named variable
arr[i]      // subscript produces lvalue
*p          // dereferencing a pointer
  </code>
</pre>



<h2>Universal/Forwarding Reference</h2>
<p>
  Suppose we have the following code:
</p>
<pre>
<code>
#include <iostream>
#include <string>
#include <utility> // for std::move

// 1. Accept const lvalue reference: we just want to read it
void log_internal(const std::string& msg) {
    std::cout << "Logging const lvalue reference: " << msg << "\n";
}

// 2. Accept non-const lvalue reference: we might modify it
void log_internal(std::string& msg) {
    msg += " [logged]";
    std::cout << "Logging non-const lvalue reference: " << msg << "\n";
}

// 3. Accept rvalue reference: we can move it
void log_internal(std::string&& msg) {
    std::cout << "Logging rvalue reference: " << msg << "\n";
}

int main() {
    std::string s1 = "Hello";
    const std::string s2 = "World";

    log_internal(s1);        // calls non-const lvalue
    log_internal(s2);        // calls const lvalue
    log_internal("Temp!");   // calls rvalue

    return 0;
}
</code>
</pre>

<p>
  Now we realize that we want to be able to log <strong>anything</strong>, not just strings. A naive approach would be to create three different template signatures:
</p>
<pre>
<code>
template <typename T>
void log_internal(const T& msg) { ... }

template <typename T>
void log_internal(T& msg) { ... }

template <typename T>
void log_internal(T&& msg) { ... }
</code>
</pre>

<p>
  The problem with this approach is that templates are supposed to reduce boilerplate, but here we are duplicating code three times. This goes against the very purpose of templates.
</p>

<h3>The proper way: Universal/Forwarding References</h3>
<p>
  Instead of writing three templates, we can use a <em>universal reference</em> and <code>std::forward</code> to perfectly forward the argument to the correct internal function. Here's an example:
</p>
<pre>
<code>
#include <iostream>
#include <string>
#include <utility> // for std::forward

// Internal implementations
void log_internal_impl(const std::string& msg) {
    std::cout << "Logging const lvalue reference: " << msg << "\n";
}

void log_internal_impl(std::string& msg) {
    msg += " [logged]";
    std::cout << "Logging non-const lvalue reference: " << msg << "\n";
}

void log_internal_impl(std::string&& msg) {
    std::cout << "Logging rvalue reference: " << msg << "\n";
}

// Forwarding template
template <typename T>
void log_internal(T&& msg) {             // universal reference
    log_internal_impl(std::forward<T>(msg));
}

int main() {
    std::string s1 = "Hello";
    const std::string s2 = "World";

    log_internal(s1);        // calls non-const lvalue
    log_internal(s2);        // calls const lvalue
    log_internal("Temp!");   // calls rvalue

    return 0;
}
</code>
</pre>

<p>
  <strong>Why this works:</strong>
</p>
<ul>
  <li><code>T&&amp</code> in a template is a <em>forwarding (universal) reference</em>, which can bind to both lvalues and rvalues.</li>
  <li><code>std::forward<T>(msg)</code> preserves the original value category: it forwards lvalues as lvalues and rvalues as rvalues.</li>
  <li>We now only need a single template function instead of three, keeping the code clean and maintainable.</li>
</ul>
